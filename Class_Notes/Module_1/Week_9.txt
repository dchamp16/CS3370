specialize
    - stack 
        - last in first out

#include <iostream>
#include <stack>

int main() {
    std::stack<int> myStack;

    // Push elements onto the stack
    myStack.push(1);
    myStack.push(2);
    myStack.push(3);

    // Print the top element
    std::cout << "Top element: " << myStack.top() << std::endl;

    // Pop elements from the stack
    while (!myStack.empty()) {
        std::cout << "Popping " << myStack.top() << std::endl;
        myStack.pop();
    }

    return 0;
}


    - queue
        - first in first out

#include <iostream>
#include <queue>

int main() {
    std::queue<int> myQueue;

    // Enqueue elements
    myQueue.push(1);
    myQueue.push(2);
    myQueue.push(3);

    // Print the front element
    std::cout << "Front element: " << myQueue.front() << std::endl;

    // Dequeue elements
    while (!myQueue.empty()) {
        std::cout << "Dequeuing " << myQueue.front() << std::endl;
        myQueue.pop();
    }

    return 0;
}

    - priority_queue
        - doesnt matter who first in as long it was priority
#include <iostream>
#include <queue>

int main() {
    std::priority_queue<int> myPriorityQueue;

    // Enqueue elements
    myPriorityQueue.push(1);
    myPriorityQueue.push(3);
    myPriorityQueue.push(2);

    // Print the top element
    std::cout << "Top element: " << myPriorityQueue.top() << std::endl;

    // Dequeue elements
    while (!myPriorityQueue.empty()) {
        std::cout << "Dequeuing " << myPriorityQueue.top() << std::endl;
        myPriorityQueue.pop();
    }

    return 0;
}

    - pair

    #include <iostream>
#include <utility>

int main() {
    // Declare a pair
    std::pair<int, std::string> p;

    // Assign values to the pair
    p = std::make_pair(1, "GitHub Copilot");

    // Print the elements of the pair
    std::cout << "The pair is: (" << p.first << ", " << p.second << ")" << std::endl;

    return 0;
}

    - map
        - map is like object in javascript has key and value

#include <iostream>
#include <map>

int main() {
    // Create a map
    std::map<std::string, int> m;

    // Insert elements into the map
    m["GitHub Copilot"] = 1;
    m["AI"] = 2;
    m["Programming"] = 3;

    // Print the elements of the map
    for(const auto& pair : m) {
        std::cout << "The key is: " << pair.first << ", The value is: " << pair.second << std::endl;
    }

    return 0;
}

stricmp

#include <cstring>
#include <iostream>

int main() {
    char str1[] = "Hello";
    char str2[] = "hello";

    // Compare strings using stricmp
    int result = stricmp(str1, str2);

    if(result == 0) {
        std::cout << "The strings are equal.";
    } else {
        std::cout << "The strings are not equal.";
    }

    return 0;
}

strcasecmp


set

#include <iostream>
#include <set>

int main() {
    std::set<int> s;

    // Insert elements
    s.insert(1);
    s.insert(2);
    s.insert(2); // This will not be inserted because 2 is already in the set

    // Print elements
    for(int element : s) {
        std::cout << element << std::endl;
    }

    return 0;
}

output: 1 2


multiset

#include <iostream>
#include <set>

int main() {
    std::multiset<int> ms;

    // Insert elements
    ms.insert(1);
    ms.insert(2);
    ms.insert(2); // This will be inserted because a multiset allows duplicates

    // Print elements
    for(int element : ms) {
        std::cout << element << std::endl;
    }

    return 0;
}

output 1 2 2
